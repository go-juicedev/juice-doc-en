代码生成
=========

juice提供了一个代码生成工具来方便开发者简化开发。

下面我们了解一下它的用法。

安装juicecli
---------------

.. code-block:: shell

    go install github.com/eatmoreapple/juice/juicecli@latest

执行完成之后，在终端输入 `juicecli` 来验证是否安装完成。

简单使用
--------------

准备一张user表，我这里演示的是mysql数据库

.. code-block:: sql

    CREATE TABLE `user` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `name` varchar(255) DEFAULT NULL,
    PRIMARY KEY (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;


我们操作数据库的时候一般先定义一个接口

.. code-block:: go

    package main

    import (
        "context"   
        "database/sql"
        "github.com/eatmoreapple/juice"
        _ "github.com/go-sql-driver/mysql"
    )

    type User struct {
        ID   int64  `column:"id" autoincr:"true"`
        Name string `param:"name" column:"name"`
    }

    type UserRepository interface {
        CreateUser(ctx context.Context, user *User) (sql.Result, error)
        DeleteUserByID(ctx context.Context, id int64) (sql.Result, error)
        UpdateUserNameByID(ctx context.Context, id int64, name string) (sql.Result, error)
        GetUserByID(ctx context.Context, id int64) (*User, error)
    }

如上所示，我们定义user表的增删改查接口，接下来我们去写mapper

新建一个config.xml

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8"?>
    <configuration>
        <environments default="prod">
            <environment id="prod">
                <dataSource>root:qwe123@tcp(localhost:3306)/database?charset=utf8mb4&amp;parseTime=true</dataSource>
                <driver>mysql</driver>
            </environment>
        </environments>

        <mappers>
            <mapper namespace="main.UserRepository">

                <insert id="CreateUser">
                    insert into user (name) values (#{name})
                </insert>

                <delete id="DeleteUserByID">
                    delete from user where id = #{param}
                </delete>

                <update id="UpdateUserNameByID">
                    update user set name = #{name} where id = #{id}
                </update>

                <select id="GetUserByID">
                    select * from user where id = #{param}
                </select>
            </mapper>
        </mappers>
    </configuration>

    

好，接下来就是见证奇迹的时刻。

我们执行命令

.. code-block:: shell

    juicecli impl --type=UserRepository --config=config.xml --namespace=main.UserRepository --output=user_repo.go 

执行完毕之后，你会发现当前的目录下面多了一个user_repo.go的文件，它的具体内容如下所示。

.. code-block:: go

    // Code generated by "juicecli impl --type=UserRepository --config=config.xml --namespace=main.UserRepository --output=user_repo.go"; DO NOT EDIT.

    package main

    import (
        "context"
        "database/sql"
        "github.com/eatmoreapple/juice"
    )

    type UserRepositoryImpl struct{}

    func (u UserRepositoryImpl) CreateUser(ctx context.Context, user *User) (result0 sql.Result, result1 error) {
        manager := juice.ManagerFromContext(ctx)
        var iface UserRepository = u
        executor := juice.NewGenericManager[any](manager).Object(iface.CreateUser)
        return executor.ExecContext(ctx, user)
    }

    func (u UserRepositoryImpl) DeleteUserByID(ctx context.Context, id int64) (result0 sql.Result, result1 error) {
        manager := juice.ManagerFromContext(ctx)
        var iface UserRepository = u
        executor := juice.NewGenericManager[any](manager).Object(iface.DeleteUserByID)
        return executor.ExecContext(ctx, id)
    }

    func (u UserRepositoryImpl) UpdateUserNameByID(ctx context.Context, id int64, name string) (result0 sql.Result, result1 error) {
        manager := juice.ManagerFromContext(ctx)
        var iface UserRepository = u
        executor := juice.NewGenericManager[any](manager).Object(iface.UpdateUserNameByID)
        return executor.ExecContext(ctx, juice.H{"id": id, "name": name})
    }

    func (u UserRepositoryImpl) GetUserByID(ctx context.Context, id int64) (result0 *User, result1 error) {
        manager := juice.ManagerFromContext(ctx)
        var iface UserRepository = u
        executor := juice.NewGenericManager[User](manager).Object(iface.GetUserByID)
        ret, err := executor.QueryContext(ctx, id)
        return &ret, err
    }

    // NewUserRepository returns a new UserRepository.
    func NewUserRepository() UserRepository {
        return &UserRepositoryImpl{}
    }


它自动帮我们实现了一个刚刚的定义的接口的具体的实现。

那怎么用呢？

我们补全我们刚刚的代码

.. code-block:: go

    package main

    import (
        "context"
        "database/sql"
        "fmt"
        "github.com/eatmoreapple/juice"
        _ "github.com/go-sql-driver/mysql"
    )

    type User struct {
        ID   int64  `column:"id" autoincr:"true"`
        Name string `param:"name" column:"name"`
    }

    type UserRepository interface {
        CreateUser(ctx context.Context, user *User) (sql.Result, error)
        DeleteUserByID(ctx context.Context, id int64) (sql.Result, error)
        UpdateUserNameByID(ctx context.Context, id int64, name string) (sql.Result, error)
        GetUserByID(ctx context.Context, id int64) (*User, error)
    }

    func main() {

        cfg, err := juice.NewXMLConfiguration("config.xml")
        if err != nil {
            panic(err)
        }

        engine, err := juice.DefaultEngine(cfg)
        if err != nil {
            panic(err)
        }

        ctx := juice.ContextWithManager(context.Background(), engine)

        userRepo := NewUserRepository()

        // create user
        user := &User{
            Name: "eatmoreapple",
        }
        result, err := userRepo.CreateUser(ctx, user)
        if err != nil {
            panic(err)
        }

        id, err := result.LastInsertId()
        if err != nil {
            panic(err)
        }

        // get user
        user, err = userRepo.GetUserByID(ctx, id)
        if err != nil {
            panic(err)
        }
        fmt.Println(user)
    }

运行代码

.. code-block:: go

    go run .

这里注意不要 ``go run main.go``

控制台输出

.. code-block:: shell

    [juice] 2023/06/13 14:41:05 [main.UserRepository.CreateUser]  insert into user (name) values (?)  [eatmoreapple]  6.745625ms
    [juice] 2023/06/13 14:41:05 [main.UserRepository.GetUserByID]  select * from user where id = ?  [1]  483.166µs
    &{1 eatmoreapple}


好了，现在来解释一下我们刚刚的命令是什么意思？

* impl: 表示我们需要生成接口的实现

    * type: 指定我们要生成哪个接口的实现，这里填接口的名字。
    * config: 指定我们配置文件的路径名。
    * namespace: 表示我们去配置文件的那里去找我们需要实现的action。
    * output: 我们生成的文件的名字。

.. attention::

    接口定义的名字必须和指定的namespace下的action的id一致。

其实这个命令我们可以简化一下。

config 可以指定，它会自动从执行命令的路径的同级目录下去找有没有 config.xml 或者 config/config.xml 这个文件。

namespace 也可以不指定，它会自动去找go.mod这个文件和你接口定义的go文件中间的相对路径，将它作为namespace

所以这个命令我们可以简化写成

.. code-block:: go

    juicecli impl --type=UserRepository --output=user_repo.go 


其实output也可以不写，它会默认输出到控制台。

接口约束
----------
需要注意的是，虽然juicecli能够去解析接口签名来自动生成接口实现，但它是有它自己的规则的。

1、接口的定义每个函数的第一个参数都必须是 `context.Context`。

2、每个函数都必须有一个error的返回值，且必须作为最后一个参数。(go style)

3、当函数名对应的id的 `action` 是 `select`，也就是查询的时候，那么当前函数必须有一个映射结果的返回值。(没有返回值你查什么呢？)

4、当函数名对应的id的 `action` 不是 `select`，那么当前的函数可以有只有一个error的函数值。
如果有2个返回值，那么第一个必须为 `sql.Result` 类型。

5、函数可以有多个参数，当参数超过2个（第一个为context）的时候，juice会将除context以外的参数用map来包装一层，map的key即为函数定义时行参的名字。

6、在调用的时候，context必须是一个带有manager实现的context。可以通过 `juice.ContextWithManager` 返回的context来传递。

go generate
-----------------

.. code-block:: go

    //go:generate juicecli impl --type UserRepository --output user_repo.go
    type UserRepository interface {
        CreateUser(ctx context.Context, user *User) (sql.Result, error)
        DeleteUserByID(ctx context.Context, id int64) (sql.Result, error)
        UpdateUserNameByID(ctx context.Context, id int64, name string) (sql.Result, error)
        GetUserByID(ctx context.Context, id int64) (*User, error)
    }

在你的接口定义处写上这么一句，然后在控制台执行 `go generate` 即可生成对应的代码。
