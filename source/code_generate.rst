Code Generation
===============

Juice provides a code generation tool to help developers simplify development. Let’s learn how to use it.

Installing juicecli
-------------------

.. code-block:: shell

    go install github.com/eatmoreapple/juice/juicecli@latest

After completion, type `juicecli` in the terminal to verify if the installation is successful.

Basic Usage
-----------

Prepare a user table, demonstrated here using a MySQL database.

.. code-block:: sql

    CREATE TABLE `user` (
      `id` int(11) NOT NULL AUTO_INCREMENT,
      `name` varchar(255) DEFAULT NULL,
      PRIMARY KEY (`id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;

Typically, when operating on a database, we first define an interface.

.. code-block:: go

    package main

    import (
      "context"
      "database/sql"
      "github.com/eatmoreapple/juice"
      _ "github.com/go-sql-driver/mysql"
    )

    type User struct {
      ID int64 `column:"id" autoincr:"true"`
      Name string `param:"name" column:"name"`
    }

    type UserRepository interface {
      CreateUser(ctx context.Context, user *User) (sql.Result, error)
      DeleteUserByID(ctx context.Context, id int64) (sql.Result, error)
      UpdateUserNameByID(ctx context.Context, id int64, name string) (sql.Result, error)
      GetUserByID(ctx context.Context, id int64) (*User, error)
    }

As demonstrated, we define the CRUD interface for the user table. Next, we will write the mapper.

Create a config.xml.

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8"?>
    <configuration>
      <environments default="prod">
        <environment id="prod">
          <dataSource>root:qwe123@tcp(localhost:3306)/database?charset=utf8mb4&amp;parseTime=true</dataSource>
          <driver>mysql</driver>
        </environment>
      </environments>
      <mappers>
        <mapper namespace="main.UserRepository">
          <insert id="CreateUser">
            insert into user (name) values (#{name})
          </insert>
          <delete id="DeleteUserByID">
            delete from user where id = #{param}
          </delete>
          <update id="UpdateUserNameByID">
            update user set name = #{name} where id = #{id}
          </update>
          <select id="GetUserByID">
            select * from user where id = #{param}
          </select>
        </mapper>
      </mappers>
    </configuration>

Now, to witness the magic.

.. code-block:: shell

    juicecli impl --type=UserRepository --config=config.xml --namespace=main.UserRepository --output=user_repo.go

After executing the above command, a file named `user_repo.go` will appear in the current directory, and the content is as follows.

.. code-block:: go

    // Code generated by "juicecli impl --type=UserRepository --config=config.xml --namespace=main.UserRepository --output=user_repo.go"; DO NOT EDIT.
    package main

    import (
      "context"
      "database/sql"
      "github.com/eatmoreapple/juice"
    )

    type UserRepositoryImpl struct{}

    func (u UserRepositoryImpl) CreateUser(ctx context.Context, user *User) (result0 sql.Result, result1 error) {
      manager := juice.ManagerFromContext(ctx)
      var iface UserRepository = u
      executor := juice.NewGenericManager[any](manager).Object(iface.CreateUser)
      return executor.ExecContext(ctx, user)
    }

    func (u UserRepositoryImpl) DeleteUserByID(ctx context.Context, id int64) (result0 sql.Result, result1 error) {
      manager := juice.ManagerFromContext(ctx)
      var iface UserRepository = u
      executor := juice.NewGenericManager[any](manager).Object(iface.DeleteUserByID)
      return executor.ExecContext(ctx, id)
    }

    func (u UserRepositoryImpl) UpdateUserNameByID(ctx context.Context, id int64, name string) (result0 sql.Result, result1 error) {
      manager := juice.ManagerFromContext(ctx)
      var iface UserRepository = u
      executor := juice.NewGenericManager[any](manager).Object(iface.UpdateUserNameByID)
      return executor.ExecContext(ctx, juice.H{"id": id, "name": name})
    }

    func (u UserRepositoryImpl) GetUserByID(ctx context.Context, id int64) (result0 *User, result1 error) {
      manager := juice.ManagerFromContext(ctx)
      var iface UserRepository = u
      executor := juice.NewGenericManager[User](manager).Object(iface.GetUserByID)
      ret, err := executor.QueryContext(ctx, id)
      return &ret, err
    }

    // NewUserRepository returns a new UserRepository.
    func NewUserRepository() UserRepository {
      return &UserRepositoryImpl{}
    }

Complete the code we just started.

.. code-block:: go

    package main

    import (
      "context"
      "database/sql"
      "fmt"
      "github.com/eatmoreapple/juice"
      _ "github.com/go-sql-driver/mysql"
    )

    type User struct {
      ID int64 `column:"id" autoincr:"true"`
      Name string `param:"name" column:"name"`
    }

    type UserRepository interface {
      CreateUser(ctx context.Context, user *User) (sql.Result, error)
      DeleteUserByID(ctx context.Context, id int64) (sql.Result, error)
      UpdateUserNameByID(ctx context.Context, id int64, name string) (sql.Result, error)
      GetUserByID(ctx context.Context, id int64) (*User, error)
    }

    func main() {
      cfg, err := juice.NewXMLConfiguration("config.xml")
      if err != nil {
        panic(err)
      }
      engine, err := juice.DefaultEngine(cfg)
      if err != nil {
        panic(err)
      }
      ctx := juice.ContextWithManager(context.Background(), engine)
      userRepo := NewUserRepository()

      // create user
      user := &User{
        Name: "eatmoreapple",
      }
      result, err := userRepo.CreateUser(ctx, user)
      if err != nil {
        panic(err)
      }
      id, err := result.LastInsertId()
      if err != nil {
        panic(err)
      }

      // get user
      user, err = userRepo.GetUserByID(ctx, id)
      if err != nil {
        panic(err)
      }
      fmt.Println(user)
    }

Run the code.

.. code-block:: go

    go run .

Note: Don't use ``go run main.go``

Console Output.

.. code-block:: shell

    [juice] 2023/06/13 14:41:05 [main.UserRepository.CreateUser] insert into user (name) values (?) [eatmoreapple] 6.745625ms
    [juice] 2023/06/13 14:41:05 [main.UserRepository.GetUserByID] select * from user where id = ? [1] 483.166µs
    &{1 eatmoreapple}

Now, let's explain what the initial command does:

* impl: It indicates that we need to generate an implementation for the interface.
* type: Specifies which interface's implementation we want to generate. Here, fill in the name of the interface.
* config: Specifies the path name of our configuration file.
* namespace: Indicates where we should go in the configuration file to find the actions we need to implement.
* output: This is the name of the file that will be generated.

.. attention::

   The interface's defined name must match the id of the action under the specified namespace.

   In fact, this command can be simplified. `config` can be specified, and it will automatically search for a `config.xml` or `config/config.xml` file in the directory from where the command is executed. `namespace` also does not need to be specified, as it will automatically use the relative path between the `go.mod` file and the interface definition file in Go as the namespace.

   Thus, the command could be simplified as follows.

.. code-block:: go

    juicecli impl --type=UserRepository --output=user_repo.go

In fact, `output` can also be omitted, and by default, the output will be to the console.

Interface Constraints
---------------------

Note that although juicecli can parse interface signatures to automatically generate implementations, it has its own rules.

1. The definition of the interface requires that the first parameter of each function must be `context.Context`.

2. Each function must have an error return value, and it must be the last parameter (go style).

3. When the function name corresponds to an `action` with id `select` for queries, that function must have a return value that maps the results (what are you querying without a return value?).

4. When the function name corresponds to an `action` id other than `select`, then the function can have only one error return value. If it has 2 return values, the first must be of type `sql.Result`.

5. Functions can have multiple parameters; when more than 2 parameters are present (the first being context), juice will wrap the parameters in a map, excluding context, with the map key being the name defined in the function's parameters.

6. During invocation, the context must be one with a manager implementation. It can be passed using the context returned from `juice.ContextWithManager`.

go generate
-----------

.. code-block:: go

    //go:generate juicecli impl --type UserRepository --output user_repo.go
    type UserRepository interface {
      CreateUser(ctx context.Context, user *User) (sql.Result, error)
      DeleteUserByID(ctx context.Context, id int64) (sql.Result, error)
      UpdateUserNameByID(ctx context.Context, id int64, name string) (sql.Result, error)
      GetUserByID(ctx context.Context, id int64) (*User, error)
    }

Simply place this line above the definition of your interface, and then execute `go generate` in the console to generate the corresponding code.